package pg

import (
	"context"
	"database/sql"
	"errors"
	"time"

	"github.com/jackc/pgerrcode"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/nasik90/gophermart/internal/app/storage"
)

type Store struct {
	conn *sql.DB
}

func NewStore(conn *sql.DB) (*Store, error) {
	s := &Store{conn: conn}
	err := s.Bootstrap(context.Background())
	if err != nil {
		return s, err
	}
	return s, nil
}

func (s Store) Close() error {
	return s.conn.Close()
}

// Bootstrap подготавливает БД к работе, создавая необходимые таблицы и индексы
func (s Store) Bootstrap(ctx context.Context) error {
	// запускаем транзакцию
	tx, err := s.conn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	// в случае неуспешного коммита все изменения транзакции будут отменены
	defer tx.Rollback()

	// TODO изучить как лучше хранить пароли
	// TODO создать индексы
	// таблица пользователей
	tx.ExecContext(ctx, `
	    CREATE TABLE IF NOT EXISTS users (
	        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	        login varchar(512) CONSTRAINT login_ukey UNIQUE NOT NULL ,
			password varchar(512) NOT NULL
	    )
	`)

	// таблица заказов
	tx.ExecContext(ctx, `
	    CREATE TABLE IF NOT EXISTS orders (
	        id bigint CONSTRAINT id_pkey PRIMARY KEY NOT NULL,
			user_id int NOT NULL,
			uploaded_at timestamp NOT NULL
	    )
	`)

	// таблица видов значений статусов заказа
	tx.ExecContext(ctx, `
	    CREATE TABLE IF NOT EXISTS status_values_kinds (
	        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			name varchar(512) NOT NULL
	    )
	`)

	// заполнение таблицы видов значений статусов заказа
	tx.ExecContext(ctx, statusValuesKindsQueryText())

	// таблица для хранения истории статусов
	tx.ExecContext(ctx, `
		CREATE TABLE IF NOT EXISTS history_statuses
		(
			date_time timestamp NOT NULL,
			order_id bigint NOT NULL,
			status_id int NOT NULL,
			CONSTRAINT unique_key UNIQUE (date_time, order_id)
		)
	`)

	// таблица для хранения текущего статуса
	tx.ExecContext(ctx, `
		CREATE TABLE IF NOT EXISTS current_statuses
		(
			order_id bigint NOT NULL,
			status_id int NOT NULL,
			date_time timestamp NOT NULL,
			CONSTRAINT unique_order_id UNIQUE (order_id)
		)
	`)

	// таблица для движений баллов
	// flow_in - true, если поступление баллов, false, если расход
	// point - количество баллов
	if _, err := tx.ExecContext(ctx, `
	CREATE TABLE IF NOT EXISTS orders_points
		(
			date_time timestamp NOT NULL,
			order_id bigint NOT NULL,
			user_id bigint NOT NULL,
			flow_in boolean DEFAULT false,
			points numeric NOT NULL,
			CONSTRAINT orders_points_unique_key UNIQUE (order_id, flow_in)
		)
    `); err != nil {
		return err
	}

	// таблица для остатков по покупателю
	// Сделать заполнение через триггер, когда добавляется запись в points_history
	if _, err := tx.ExecContext(ctx, `
	CREATE TABLE IF NOT EXISTS users_current_points
		(
			user_id int NOT NULL,
			points_in numeric NOT NULL,
			points_out numeric NOT NULL,
			balance numeric NOT NULL,
			CONSTRAINT users_current_points_unique_order_id UNIQUE (user_id)
		)
    `); err != nil {
		return err
	}

	// коммитим транзакцию
	return tx.Commit()
}

func statusValuesKindsQueryText() string {
	return `INSERT INTO status_values_kinds (name) VALUES ('NEW'), ('PROCESSING'), ('INVALID'), ('PROCESSED')`
}

func (s *Store) SaveNewUser(ctx context.Context, login, password string) error {
	_, err := s.conn.ExecContext(ctx, `INSERT INTO users (login, password) VALUES ($1, $2)`, login, password)
	err = saveNewUserCheckInsertError(err)
	return err
}

func saveNewUserCheckInsertError(err error) error {
	if err == nil {
		return nil
	}
	var pgErr *pgconn.PgError
	if errors.As(err, &pgErr) && pgErr.Code == pgerrcode.UniqueViolation {
		if pgErr.ConstraintName == "login_ukey" {
			return storage.ErrUserNotUnique
		}
	}
	return err
}

func (s *Store) UserIsValid(ctx context.Context, login, password string) (bool, error) {
	rows, err := s.conn.ExecContext(ctx, `SELECT FROM users WHERE login = $1 and password = $2`, login, password)
	if err != nil {
		return false, err
	}
	rowsAffected, err := rows.RowsAffected()
	if err != nil {
		return false, err
	}
	if rowsAffected > 0 {
		return true, nil
	}
	return false, nil
}

func (s *Store) SaveNewOrder(ctx context.Context, id int, login string) error {

	userID, err := s.getUserID(ctx, login)
	if err != nil {
		return err
	}

	tx, err := s.conn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()

	err = createOrderWithStatusNew(ctx, tx, id, userID)
	if err != nil {
		return err
	}

	return tx.Commit()
}

func createOrderWithStatusNew(ctx context.Context, tx *sql.Tx, id int, userID int) error {
	uploadedAt := time.Now()
	_, err := tx.ExecContext(ctx, `
        INSERT INTO orders (id, user_id, uploaded_at) VALUES ($1, $2, $3)`,
		id, userID, uploadedAt)

	err = saveNewOrderCheckInsertError(err)
	if err == storage.ErrOrderIDNotUnique {
		row := tx.QueryRowContext(ctx, `SELECT user_id FROM orders WHERE id = $1`, id)
		var OrderUserID int
		if err := row.Scan(&OrderUserID); err != nil {
			return err
		}
		if OrderUserID != userID {
			return storage.ErrOrderLoadedByAnotherUser
		}
	}
	if err != nil {
		return err
	}
	//Переделать установку статуса через триггеры в постгри https://postgrespro.ru/docs/postgresql/9.6/plpgsql-trigger
	//В триггере должно всегда устанавливаться текущее время при инсерте и автоматом обновляться запись в current_statuses
	if _, err = tx.ExecContext(ctx,
		`INSERT INTO history_statuses (date_time, order_id, status_id) VALUES ($1, $2, $3)`,
		uploadedAt, id, 1); err != nil {
		return err
	}

	if _, err = tx.ExecContext(ctx,
		`INSERT INTO current_statuses (order_id, status_id, date_time)
		VALUES ($1, $2, $3)
	 	ON CONFLICT (order_id)
		DO UPDATE SET status_id = $2, date_time = $3;`,
		id, 1, uploadedAt); err != nil {
		return err
	}
	return nil
}

func saveNewOrderCheckInsertError(err error) error {
	if err == nil {
		return nil
	}
	var pgErr *pgconn.PgError
	if errors.As(err, &pgErr) && pgErr.Code == pgerrcode.UniqueViolation {
		if pgErr.ConstraintName == "id_pkey" {
			return storage.ErrOrderIDNotUnique
		}
	}
	return err
}

func (s *Store) getUserID(ctx context.Context, login string) (int, error) {
	row := s.conn.QueryRowContext(ctx, `SELECT id FROM users WHERE login = $1`, login)
	var userID int
	if err := row.Scan(&userID); err != nil {
		return 0, err
	}
	return userID, nil
}

func (s *Store) getUserByOrder(ctx context.Context, OrderID int) (int, error) {
	row := s.conn.QueryRowContext(ctx, `SELECT user_id FROM orders WHERE id = $1`, OrderID)
	var userID int
	if err := row.Scan(&userID); err != nil {
		return 0, err
	}
	return userID, nil
}

func (s *Store) GetOrderList(ctx context.Context, login string) (*[]storage.OrderData, error) {
	var result []storage.OrderData

	// queryText :=
	// 	`SELECT orders.id
	// 		,COALESCE(status_values_kinds.name, '') as status
	// 		,orders.uploaded_at
	// 		,COALESCE(orders_points.points, 0) as accrual
	// 	FROM orders
	// 		INNER JOIN users
	// 		ON orders.user_id = users.id
	// 		LEFT JOIN current_statuses
	// 		ON orders.id = current_statuses.order_id
	// 		LEFT JOIN status_values_kinds
	// 		ON current_statuses.status_id = status_values_kinds.id
	// 		LEFT JOIN orders_points
	// 		ON orders.id = orders_points.order_id
	// 	WHERE users.login = $1
	// 	`

	queryText :=
		`SELECT orders.id
			,'' as status
			,orders.uploaded_at
			,0 as accrual
		FROM orders
			INNER JOIN users
			ON orders.user_id = users.id
		WHERE users.login = $1
		`
	rows, err := s.conn.QueryContext(ctx, queryText, login)
	if err != nil {
		return nil, err
	}
	for rows.Next() {
		orderData := new(storage.OrderData)
		if err := rows.Scan(&orderData.Number, &orderData.Status, &orderData.UploadedAt, &orderData.Accrual); err != nil {
			return nil, err
		}
		result = append(result, *orderData)
	}

	if err := rows.Err(); err != nil {
		return &result, err
	}

	return &result, nil
}

func (s *Store) WithdrawPoints(ctx context.Context, login string, OrderID int, points float32) error {
	userID, err := s.getUserID(ctx, login)
	if err != nil {
		return err
	}

	tx, err := s.conn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()

	if _, err := tx.ExecContext(ctx, `
		SELECT user_id 
		FROM users_current_points
		WHERE user_id = $1 FOR UPDATE
	`, userID); err != nil {
		return err
	}

	res, err := tx.ExecContext(ctx, `
		UPDATE users_current_points SET points_out = points_out + $1, balance = balance - $1  WHERE user_id = $2 
	`, points, userID)
	if err != nil {
		return err
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return err
	}
	// Если ничего не обновили, значит нет баллов у покупателя
	if rowsAffected == 0 {
		return storage.ErrOutOfBalance
	} else {
		//Проверяем не ушли ли в минус
		rows, err := tx.QueryContext(ctx, `
			SELECT balance FROM users_current_points WHERE user_id = $1 and balance < 0
		`, userID)
		if err != nil {
			return err
		}
		defer rows.Close()
		for rows.Next() {
			return storage.ErrOutOfBalance
		}
		if err := rows.Err(); err != nil {
			return err
		}
	}
	// Создем заказ
	err = createOrderWithStatusNew(ctx, tx, OrderID, userID)
	if err != nil {
		return err
	}

	// Пишем в таблицу orders_points
	_, err = tx.ExecContext(ctx, `
		INSERT INTO orders_points (date_time, order_id, user_id, flow_in, points) VALUES ($1, $2, $3, $4, $5)
		`, time.Now(), OrderID, userID, false, points)
	if err != nil {
		return err
	}

	return tx.Commit()
}

func (s *Store) AccruePoints(ctx context.Context, OrderID int, points float32) error {
	userID, err := s.getUserByOrder(ctx, OrderID)
	if err != nil {
		return err
	}

	tx, err := s.conn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()

	if _, err := tx.ExecContext(ctx, `
		SELECT user_id 
		FROM users_current_points
		WHERE user_id = $1 FOR UPDATE
	`, userID); err != nil {
		return err
	}

	res, err := tx.ExecContext(ctx, `
		UPDATE users_current_points SET points_in = points_in + $1, balance = balance + $1  WHERE user_id = $2 
	`, points, userID)
	if err != nil {
		return err
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return err
	}
	// Если ничего не обновили, то добавляем баллы
	if rowsAffected == 0 {
		_, err := tx.ExecContext(ctx, `
			INSERT INTO users_current_points (user_id, points_in, points_out, balance) VALUES ($1, $2, $3, $4) 
		`, userID, points, 0, points)
		if err != nil {
			return err
		}
	}

	// Пишем в таблицу orders_points
	_, err = tx.ExecContext(ctx, `
		INSERT INTO orders_points (date_time, order_id, user_id, flow_in, points) VALUES ($1, $2, $3, $4, $5)
		`, time.Now(), OrderID, userID, true, points)
	if err != nil {
		return err
	}

	return tx.Commit()
}
